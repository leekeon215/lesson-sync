<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./opensheetmusicdisplay.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; }
        #score-container { width: 100%; }
        svg { width: 100%; height: auto; }

        /* 주석 스타일 */
        .annotation-bubble {
            opacity: 0.95;
        }
        .annotation-text {
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            font-weight: 500;
            fill: #333;
        }
    </style>
</head>
<body>
<div id="score-container"></div>
<script>
    /**
     * 모든 상태를 받아 화면을 업데이트하는 최종 마스터 함수
     */
    function updateDisplay(state) {
        if (!window.osmd || !window.isScoreLoaded) {
            // OSMD가 준비되지 않았거나, 초기 load가 끝나지 않았으면 아무것도 하지 않음
            return;
        }

        try {
            // 1. 줌 레벨을 설정합니다.
            window.osmd.zoom = state.zoom;

            // 2. 악보를 동기적으로 다시 그립니다. 이 라인이 끝나면 악보가 화면에 그려진 상태입니다.
            window.osmd.render();

            // --- 해결 방안: render() 후 짧은 지연 추가 ---
            // render()가 내부적으로 그래픽 계산을 완료할 시간을 확보합니다.
            setTimeout(() => {
                console.log("Render finished. Drawing annotations and highlight.");

                clearAllAnnotations();

                const availableMeasures = getMeasureCount();
                console.log(`Score has ${availableMeasures} available measure(s)`);

                if (state.annotations && state.annotations.length > 0) {
                    const validAnnotations = state.annotations
                        .filter(a => a.measure > 0 && a.measure <= availableMeasures)
                        .sort((a, b) => a.measure - b.measure);

                    const invalidAnnotations = state.annotations
                        .filter(a => a.measure <= 0 || a.measure > availableMeasures);

                    if (invalidAnnotations.length > 0) {
                        console.log(`Filtered out ${invalidAnnotations.length} annotations with invalid measure numbers`);
                    }

                    console.log("Adding annotations:", JSON.stringify(validAnnotations));
                    validAnnotations.forEach(a => addAnnotationToMeasure(a.measure, a.text));
                }

                toggleAnnotations(state.showAnnotations);

                const measureToHighlight = state.highlightMeasure;
                if (measureToHighlight !== null && measureToHighlight > 0 && measureToHighlight <= availableMeasures) {
                    highlightMeasure(measureToHighlight);
                } else if (measureToHighlight !== null) {
                    console.log(`Cannot highlight measure ${measureToHighlight} - out of bounds (1-${availableMeasures})`);
                    if (window.osmd && window.osmd.cursor) {
                        window.osmd.cursor.hide();
                    }
                }
            }, 200); // 200ms 정도의 지연을 줍니다.

        } catch(e) {
            console.error("Error in updateDisplay: ", e);
        }
    }

    // 악보의 마디 수를 얻는 헬퍼 함수
    function getMeasureCount() {
        try {
             if (window.osmd && window.osmd.graphic && window.osmd.graphic.measureList) {
                const measureCount = window.osmd.graphic.measureList.length;
                console.log("Getting measure count from graphic object: " + measureCount);
                return measureCount;
            }
            else {
                console.warn("OSMD or sheet data not available");
            }
        } catch (e) {
            console.error("Error getting measure count:", e);
        }
        return 0;
    }

    function highlightMeasure(measureNumber) {
        const cursor = window.osmd ? window.osmd.cursor : undefined;
        if (!cursor) return;

        if (measureNumber === null || measureNumber < 1) {
            cursor.hide();
            return;
        }
        try {
            cursor.show();
            cursor.reset();
            const targetMeasureIndex = measureNumber - 1;
            while (cursor.iterator.currentMeasureIndex < targetMeasureIndex && !cursor.iterator.endReached) {
                cursor.next();
            }
            cursor.update();
        } catch (e) {
            console.error("Error highlighting measure " + measureNumber + ": ", e);
            cursor.hide();
        }
    }

    function addAnnotationToMeasure(measureNumber, text) {
        const osmd = window.osmd;
        if (!osmd || !osmd.graphic) {
            console.error("OSMD or graphic not ready");
            return;
        }

        const svgRoot = osmd.container.querySelector("svg");
        if (!svgRoot) {
            console.error("SVG root not found");
            return;
        }

        let annotationLayer = svgRoot.querySelector("#annotation-layer");
        if (!annotationLayer) {
            annotationLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
            annotationLayer.setAttribute("id", "annotation-layer");
            svgRoot.appendChild(annotationLayer);
            scaleAnnotationLayer(osmd.zoom);
        }

        // 수정된 부분: 올바른 방법으로 measure에 접근
        try {
            // measureList를 얻기 위한 안전한 방법
            if (!osmd.graphic.measureList || osmd.graphic.measureList.length === 0) {
                console.error("Measure list not available");
                return;
            }

            // 마디 번호에 해당하는 인덱스는 1을 빼야함
            const index = measureNumber - 1;

            const measure = osmd.graphic.measureList[index][0];
            if (!measure || !measure.PositionAndShape) {
                console.error("Measure or position not found for index:", index);
                return;
            }

            const measurePos = measure.PositionAndShape.AbsolutePosition;
            const x = measurePos.x * 10;
            const y = measurePos.y * 10 - 30; // 위치 약간 위로 조정

            console.log(`Adding annotation at measure ${measureNumber}, pos: (${x}, ${y}), text: ${text}`);

            // 말풍선 그룹 생성
            const bubbleGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            bubbleGroup.setAttribute("class", "annotation-bubble");
            bubbleGroup.setAttribute("cursor", "pointer");
            bubbleGroup.setAttribute("data-measure", measureNumber);
            bubbleGroup.setAttribute("onclick", `requestAnnotationDeletion(${measureNumber})`);

            // 말풍선 패스 생성
            const bubble = document.createElementNS("http://www.w3.org/2000/svg", "path");

            // 텍스트 요소 생성 및 크기 계산을 위한 임시 추가
            const tempText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            tempText.setAttribute("font-size", "12px");
            tempText.setAttribute("font-family", "Arial");
            tempText.textContent = text;
            svgRoot.appendChild(tempText); // body 대신 svgRoot에 추가하여 정확한 SVG 컨텍스트에서 측정

            // 텍스트 크기 측정
            let textWidth = 0;
            try {
                const bbox = tempText.getBBox();
                textWidth = bbox.width;
            } catch (e) {
                // getBBox 실패 시 대체 계산법(더 넉넉하게)
                textWidth = text.length * 8;
            }

            svgRoot.removeChild(tempText);

            // 텍스트가 잘리지 않도록 여유 공간 추가 (20% 추가)
            textWidth = textWidth * 1.2;

            const paddingX = 10;
            const paddingY = 8;
            const bubbleWidth = textWidth + (paddingX * 2);
            const bubbleHeight = 24; // 기본 높이
            const cornerRadius = 6;
            const tailSize = 6;

            // 말풍선 패스 정의 (꼬리가 아래로 향하는 말풍선)
            const pathData = `
                M${x},${y + cornerRadius}
                Q${x},${y} ${x + cornerRadius},${y}
                H${x + bubbleWidth - cornerRadius}
                Q${x + bubbleWidth},${y} ${x + bubbleWidth},${y + cornerRadius}
                V${y + bubbleHeight - cornerRadius}
                Q${x + bubbleWidth},${y + bubbleHeight} ${x + bubbleWidth - cornerRadius},${y + bubbleHeight}
                H${x + (bubbleWidth/2) + tailSize}
                L${x + (bubbleWidth/2)},${y + bubbleHeight + tailSize}
                L${x + (bubbleWidth/2) - tailSize},${y + bubbleHeight}
                H${x + cornerRadius}
                Q${x},${y + bubbleHeight} ${x},${y + bubbleHeight - cornerRadius}
                V${y + cornerRadius}
                Z
            `;

            bubble.setAttribute("d", pathData);
            bubble.setAttribute("fill", "#FFFFE0"); // 연한 노란색
            bubble.setAttribute("stroke", "#888888");
            bubble.setAttribute("stroke-width", "1");
            bubble.setAttribute("filter", "drop-shadow(2px 2px 2px rgba(0,0,0,0.2))");

            // 텍스트 생성
            const svgText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            svgText.setAttribute("x", x + paddingX);
            svgText.setAttribute("y", y + 16); // 텍스트 수직 중앙 정렬
            svgText.setAttribute("class", "annotation-text");
            svgText.textContent = text;

            // 그룹에 요소 추가
            bubbleGroup.appendChild(bubble);
            bubbleGroup.appendChild(svgText);
            annotationLayer.appendChild(bubbleGroup);
        } catch (e) {
            console.error("Error adding annotation to measure", measureNumber, ":", e);
        }
    }

    // --- ▼ [추가] JavaScript에서 Kotlin을 호출하는 함수 ---
    function requestAnnotationDeletion(measureNumber) {
        // JsBridge를 통해 Android(Kotlin) 코드로 measureNumber를 전달합니다.
        if (window.jsBridge) {
            window.jsBridge.requestDelete(measureNumber);
        }
    }

    function scaleAnnotationLayer(zoom) {
        const annotationLayer = document.querySelector("#annotation-layer");
        if (annotationLayer) {
            annotationLayer.setAttribute('transform', 'scale(' + zoom + ')');
        }
    }

    function toggleAnnotations(shouldShow) {
        const annotationLayer = document.querySelector("#annotation-layer");
        if (annotationLayer) {
            annotationLayer.style.visibility = shouldShow ? 'visible' : 'hidden';
        }
    }

    function clearAllAnnotations() {
        const annotationLayer = document.querySelector("#annotation-layer");
        if (annotationLayer) {
            annotationLayer.innerHTML = '';
        }
    }
</script>
</body>
</html>